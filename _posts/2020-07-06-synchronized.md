---
layout:    post
title:     Synchronized 关键字的底层实现
category:  JVM
tags: Synchronized
---

> 1. 针对方法，会添加一个 ACC_SYNCHRONIZED 修饰方法，在执行方法时，先要获取到 monitor 的锁才能继续执行；
> 2. 针对方法块，会通过字节码 monitor_enter、monitor_exit 的字节码来实现。

传统的锁（也就是下文要说的重量级锁）依赖于系统的同步函数，在linux上使用mutex互斥锁，最底层实现依赖于futex，关于futex可以看这些文章，这些同步函数都涉及到用户态和内核态的切换、进程的上下文切换，成本较高。1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。

## 对象的内存模型
```
 ----------------
|	mark word    |  --> 用于记录 锁标志位 （2 位）、是否偏向锁（1 位）、对象的 hashCode、线程 id（偏向锁）、互斥量指针（重量级锁）、栈中锁记录指针（轻量级锁）
 ---------------- 
|   class ptr    |  --> class 对象类型
 ----------------
|    (length)    |  --> 如果是数组对象，才有这个字段
 ----------------
| 	  filed1     | 
|	 ......		 |  --> 属性字段
|	  filedn     |
 ----------------
|  	padding		 |  --> 对齐
 ----------------	
```

## 锁升级
### 偏向锁
    1）访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。
	2）如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。
	3）如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。
	4）如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）
	5）执行同步代码。
### 轻量级锁
JVM的开发者发现在很多情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。线程在执行同步块之前，JVM会先在当前的线程的栈帧中创建一个Lock Record，其包括一个用于存储对象头中的 mark word（官方称之为Displaced Mark Word）以及一个指向对象的指针。下图右边的部分就是一个Lock Record。
```
 ----------------        ------------------- -------
|	mark word    |  <--	|  displaced record | owner |  <-- Lock Record 空间
 ---------------- 		 ------------------- -------
|   class ptr    |  --> class 对象类型
 ----------------
|    (length)    |  --> 如果是数组对象，才有这个字段
 ----------------
| 	  filed1     |
|	  ......	 |  --> 属性字段
|	  filedn     |
 ----------------
|  	padding		 |  --> 对齐
 ----------------	
```
加锁的过程如下
```
    a) 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word；
    b）拷贝对象头中的Mark Word复制到锁记录（Lock Record）中；
    c）拷贝成功后，虚拟机将使用CAS操作尝试将锁对象的Mark Word更新为指向Lock Record的指针，并将线程栈帧中的Lock Record里的owner指针指向Object的 Mark Word；
    d）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态；
    e）如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，通过自旋的方式继续获取轻量级锁，如果获取成功则继续，否则轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。
```

### 重量级锁
重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。
```
						    The owner
  					     -------------------------     wait set
    		entry set   |						  |---------------
     	 ---------------|					  	  |				  |
    	|    thread1	|					release ---> thread3  |
  entry ---> ......   acquire ---> thread0  	  |               |
    	|	 thread2    |					  <--- aquire thread4 |
    	|				|						  |				  |
    	 ---------------|						  |---------------|
    	 				|	    release/exit      |
    	 				 ----------- /------------
    	 				 		    /
    	 				 		thread6 	
```
其中 thread0 目前持有锁，而 thread1、thread2 都在进入拿锁的过程，还在等待获取锁；thread3、thread4 在通过 await/yield 等方式以及释放掉了当前的锁而进入了 wait 区域；而 thread6 因为线程退出释放了当前锁。

## 总结
a）偏向锁、轻量级锁都是乐观锁，重量级锁是悲观锁；
b）一个对象刚开始是没有任务线程访问的，即可偏向，当第一个线程访问时，就会设置该线程为偏向线程，于是 mark word 中就会保存该线程 id；
c）一旦第二个线程访问该对象时，若当前是偏向锁，则会升级为轻量级锁；若当前只有一个线程在等待，则该线程通过自旋进行等待，提高性能；若自旋超过一定次数或者（一个线程持有锁、一个在自旋、又来了第三个线程）则升级到重量级锁；
    
## 参考
[不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)