---
layout:    post
title:     红黑树之核心思想
category:  数据结构
tags: 红黑树
---

## 红黑树性质
  ```
  1. 节点是红色或者黑色
  2. 根节点是黑色
  3. 不能有两个相邻的红色节点（红色节点的子节点只能是黑色节点）
  4. 所有的叶子节点都是黑色节点（nil是黑色节点）
  5. 从任意根节点到叶子节点的简单路径都包含相同个数的黑色节点
  ```

## 节点插入算法

### 双红现象
由于插入一个新节点 ```X``` ，我们默认给的颜色是红色，这样就可能造成 ```X``` 与父节点 ```P``` 同为红色的此类情况，称作 ```双红现象```（double red），这就违反了红黑树的性质3。<br>
为修正 **双红缺陷** ，可调用```solveDoubleRed(x)```接口。每引入一个关键码，该接口都可能迭代地调用多次。<br>
在此过程中，当前节点 ```X``` 的兄弟及两个孩子（初始时都是外部节点），始终均为黑色。将```X```的父亲与祖父分别记作 ```P``` 和 ```G```。既然此前的红黑树合法，故作为红节点 ```P``` 的父亲，```G``` 必然存在且为黑色。```G``` 作为内部节点，其另一孩子（即 ```P``` 的兄弟、```X``` 的叔父）也必然存在,将其记作 ```U``` 。

### 双红修正
#### RR-1
考查 ```U``` 为黑色的情况。此时，```X``` 的兄弟、两个孩子的黑高度,均与 ```U``` 相等（这里我的理解是，P 和 U 有一个为红色，即父为红色的情况，所以叫 RR-1）。<br>
下图以根节点左子树为例，(B)/(R) 分别代表节点的颜色(BLACK)/(RED)，```S``` 表示的是 X 的兄弟节点，当 U 为黑色时，X 必然存在兄弟节点，不然红黑树的规则（到叶子节点的黑色节点数目相同）就会被破坏。
<pre>
        G(B)                         G(B)
        /  \                         /  \
     P(R)  U(B)                    P(R) U(B)
     /  \                          /  \
   X(R) S(B)                     S(B) X(R)
       （1）                          （2）
</pre>
面对这种情况，要分两种情况处理。<br>
* X 和 P 都是各自父节点的左或者右节点（上图1），则只需要对 G 做一次右旋或者左旋，然后对 G、P 做一次颜色交换，X 变黑即可；

* X 和 P 不是同边节点，即 X 为 P 的左节点，P 为 G 的右节点（上图1），或者即 X 为 P 的右节点，P 为 G 的左节点，这个时候，就需要先对 P 做一次左旋（或右旋），然后再对 G 做一次右旋（左旋），并且将 G 的颜色改为红色，P 的颜色改为黑色即可；
  
#### RR-2
考查节点 ```U``` 为红色的情况。此时， ```U```的左、右孩子非空且均为黑色，其黑高度必与 ```X``` 的兄弟以及两个孩子相等（这里我的理解是，P 和 U 都为红色，所以叫 RR-2）。
<pre>
        G(B)                         G(B)
        /  \                         /  \
     P(R)  U(R)                    P(R) U(R)
     /                               \  
   X(R)                              X(R)
       （1）                          （2）
</pre>
这种处理就相对来说比较简单了，由于 P 和 U 都是红色，则 G 肯定是黑色，那么只需要将 P 和 U 都改为黑色，然后将 G 改为红色，就能满足性质3，但是，由于 G 变成红色，可能导致 G 又出现“双红现象”，于是，递归对 G 再做“双红修正”。

#### 双红修正总结
红黑树的双红调整算法：解决被插入节点 X 与其父节点 P 均为红色的问题
<pre>
RR-1: 2次颜色翻转，2次黑高度更新，1~2次旋转，不再递归
RR-2: 3次颜色翻转，3次黑高度更新，0次旋转，需要递归
</pre>

## 节点删除算法
**假设要删除的节点为 dnode 且存在**

1. 如果将被删除的结点 ```dnode``` 无后继结点 ```successor``` ，则直接被删除，并被其左孩子替代其位置；
2. 如果将被删除的结点 ```dnode``` 有后继结点 ```successor```，则将后继结点的值赋给（或者将后继节点移动到，但是后继节点的颜色不会被移动过去） ```dnode``` ，并删除后继结点，再将后继结点的右孩子取代后继结点的位置，这里实际上删除的节点为后继节点 ```successor```；
3. 完成1、2的处理之后，如果红黑树的性质被破坏，则调用相关算法进行调整。
<pre>
说一下为什么当 dnode 有后继节点时，要删除其后继节点。主要原因是如果存在后继节点时，我们可以很方便的把后继节点与要删除的节点交换，并且后继节点具有一个特别明显的特征就是，最多只会有一个非叶子节点（更具体一点是，最多存在右子节点，这一点在被删除的节点具有两个子节点时非常有用，也是默认采取的策略），而这一性质可以大大简化调整的过程。
</pre>
**可能被破坏的红黑树性质** <br>
上面的第3步中提到了当红黑树性质被破坏时，需要重新调整红黑树使其满足红黑树的性质，那仔细思考一下，有哪些情况导致了红黑树的哪些性质可能被破坏了呢？<br>
在此讨论的时候，假设以下提到的删除节点为实际删除的节点，可能是 ```dnode``` 也可能是后继结点 ```successor```，讨论如下
* 若删除的是红色节点，则其子节点必然是黑色，如果存在的话，而父节点必然存在且为黑色，这种情况，不管是用左孩子或右孩子来替换，都不会导致任何性质的变化，无需调整；
* 若删除的是黑色节点，则其子节点可能是红色，也可能是黑色，父节点同样可能是红色也可能是黑色，所以不管是用左孩子或右孩子来替换，都会可能导致```性质4```被破坏，即链路上的黑色节点少了一个。针对这种情况，
* 1. 若孩子节点为```红色```时，那很好办，直接将孩子的颜色染黑即可重新满足红黑树性质；
* 2. 当孩子节点为```黑色```时，这就出现了经典的```双黑现象```（被删除节点、子节点都为黑色的情况），需要调用```双黑修正```算法来进行调整，使红黑树再次满足所有的性质。

### 双黑现象
当被删除的节点 ```dnode```  本身或者 ```successor``` 的颜色为 **BLACK** 且若其孩子节点存在并且也是 **BLACK** 时，我们称之为 ```双黑现象```。出现这种现象之后，红黑树的性质必然受到破坏，必须经过相关的调整才能重新恢复红黑树的相关性质，具体来说是```性质4```。

### 双黑修正
该算法可以分为```左右两子树```来进行，讨论时，只讨论```左子树```的情况，即被删除节点是父节点```左孩子```的情况，为```右孩子```时的情况与之对称。<br>
本来这里我打算看懂 STL 中红黑树的算法的，无奈之下没看懂，也理解不了，于是只能参照《算法导论》里面的算法进行分析和理解了，实际上，Linux 内核中的红黑树也是采用《算法导论》里面的算法的。如下：
{% highlight c++ %}
RB-DELETE-FIXUP(T, x)

while x ≠ root[T] and color[x] = BLACK  
    do if x = left[p[x]]      
          then w ← right[p[x]]                                             // 若 “x”是“它父节点的左孩子”，
                                                                           // 则设置 “w”为“x的叔叔”(即x为它父节点的右孩子)
               if color[w] = RED                                           // Case 1: x是“黑+黑”节点，x的兄弟节点是红色。
                                                                           //         (此时x的父节点和x的兄弟节点的子节点都是黑节点)。
                  then color[w] ← BLACK                        ▹  Case 1   //   (01) 将x的兄弟节点设为“黑色”。
                       color[p[x]] ← RED                       ▹  Case 1   //   (02) 将x的父节点设为“红色”。
                       LEFT-ROTATE(T, p[x])                    ▹  Case 1   //   (03) 对x的父节点进行左旋。
                       w ← right[p[x]]                         ▹  Case 1   //   (04) 左旋后，重新设置x的兄弟节点。

               if color[left[w]] = BLACK and color[right[w]] = BLACK       // Case 2: x是“黑+黑”节点，x的兄弟节点是黑色，
                                                                           //         x的兄弟节点的两个孩子都是黑色。
                  then color[w] ← RED                          ▹  Case 2   //   (01) 将x的兄弟节点设为“红色”。
                       x ←  p[x]                               ▹  Case 2   //   (02) 设置“x的父节点”为“新的x节点”。

                else if color[right[w]] = BLACK                            // Case 3: x是“黑+黑”节点，x的兄弟节点是黑色；
                                                                           //         x的兄弟节点的左孩子是红色，右孩子是黑色的。
                        then color[left[w]] ← BLACK            ▹  Case 3   //   (01) 将x兄弟节点的左孩子设为“黑色”。
                               color[w] ← RED                  ▹  Case 3   //   (02) 将x兄弟节点设为“红色”。
                               RIGHT-ROTATE(T, w)              ▹  Case 3   //   (03) 对x的兄弟节点进行右旋。
                               w ← right[p[x]]                 ▹  Case 3   //   (04) 右旋后，重新设置x的兄弟节点。

                        color[w] ← color[p[x]]                 ▹  Case 4   // Case 4: x是“黑+黑”节点，x的兄弟节点是黑色；
                                                                           //         x的兄弟节点的右孩子是红色的。
                                                                           //   (01) 将x父节点颜色 赋值给 x的兄弟节点。
                        color[p[x]] ← BLACK                    ▹  Case 4   //   (02) 将x父节点设为“黑色”。
                        color[right[w]] ← BLACK                ▹  Case 4   //   (03) 将x兄弟节点的右子节设为“黑色”。
                        LEFT-ROTATE(T, p[x])                   ▹  Case 4   //   (04) 对x的父节点进行左旋。
                        x ← root[T]                            ▹  Case 4   //   (05) 设置“x”为“根节点”。
        else (same as then clause with "right" and "left" exchanged)        // 若 “x”是“它父节点的右孩子”，将上面的操作中“right”和
                                                                           // “left”交换位置，然后依次执行。
color[x] ← BLACK
{% endhighlight %}

*<strong> 以下双黑修正各 case 中的 ```x``` ，即为删除节点后的替换上来的节点，而不是 ```dnode``` 或者 ```successor``` </strong>*
<br>
#### 双黑修正（case-1）
**x是"黑+黑"节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。**
<pre>
(01) 将x的兄弟节点设为“黑色”。
(02) 将x的父节点设为“红色”。
(03) 对x的父节点进行左旋。
(04) 左旋后，重新设置x的兄弟节点。
</pre>
<pre>
        P()                          S(B)
       /   \                        /   \
     X(B)  S(R)        --->      P(R)   Sr(B)
           /  \                  /  \   
        Sl(B) Sr(B)           X(B) Sl(B) <-- S 重新指向 X 的新兄弟
</pre>
* 这样做的目的是将“Case 1”转换为“Case 2”、“Case 3”或“Case 4”，从而进行进一步的处理。对x的父节点进行左旋；左旋后，为了保持红黑树特性，就需要在左旋前“将x的兄弟节点设为黑色”，同时“将x的父节点设为红色”；左旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。<br><br>

#### 双黑修正（case-2）
**x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。**
<pre>
(01) 将x的兄弟节点设为“红色”。
(02) 设置“x的父节点”为“新的x节点”。
</pre>
<pre>
        P()                          P()   <--- X 网上移动一层，指向 P
       /   \                        /   \
     X(B)  S(B)        --->      X(B)   S(R)
           /  \                         /  \
        Sl(B) Sr(B)                  Sl(B) Sr(B)
</pre>
* 这个情况的处理思想：是将“x中多余的一个黑色属性上移(往根方向移动)”。 x是“黑+黑”节点，我们将x由“黑+黑”节点 变成 “黑”节点，多余的一个“黑”属性移到x的父节点中，即x的父节点多出了一个黑属性(若x的父节点原先是“黑”，则此时变成了“黑+黑”；若x的父节点原先时“红”，则此时变成了“红+黑”)。 此时，需要注意的是：所有经过x的分支中黑节点个数没变化；但是，所有经过x的兄弟节点的分支中黑色节点的个数增加了1(因为x的父节点多了一个黑色属性)！为了解决这个问题，我们需要将“所有经过x的兄弟节点的分支中黑色节点的个数减1”即可，那么就可以通过“将x的兄弟节点由黑色变成红色”来实现。经过上面的步骤(将x的兄弟节点设为红色)，多余的一个颜色属性(黑色)已经跑到x的父节点中。我们需要将x的父节点设为“新的x节点”进行处理。若“新的x节点”是“黑+红”，直接将“新的x节点”设为黑色，即可完全解决该问题；若“新的x节点”是“黑+黑”，则需要对“新的x节点”进行进一步处理。<br><br>

#### 双黑修正（case-3）
**x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。**
<pre>
(01) 将x兄弟节点的左孩子设为“黑色”。
(02) 将x兄弟节点设为“红色”。
(03) 对x的兄弟节点进行右旋。
(04) 右旋后，重新设置x的兄弟节点。
</pre>
<pre>
        P()                        P()
       /  \                       /   \
     X(B) S(B)        --->      X(B) Sl(B)  <-- S 重新指向X的新兄弟
          /  \                          \
       Sl(R) Sr(B)                      S(R)
                                          \
                                          Sr(B)
</pre>
* 我们处理“Case 3”的目的是为了将“Case 3”进行转换，转换成“Case 4”,从而进行进一步的处理。转换的方式是对x的兄弟节点进行右旋；为了保证右旋后，它仍然是红黑树，就需要在右旋前“将x的兄弟节点的左孩子设为黑色”，同时“将x的兄弟节点设为红色”；右旋后，由于x的兄弟节点发生了变化，需要更新x的兄弟节点，从而进行后续处理。<br><br>

#### 双黑修正（case-4）
**x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。** <br>
*如果有仔细画前面的每一个 case 的图，你会发现，经过 case-3 的转换之后，图就到 case-4 的模样，至此我真的很敬佩当时发明这个算法的人，思维之严谨，抽象问题之深度，简直厉害的不行。* 
<pre>
(01) 将x父节点颜色赋值给x的兄弟节点。
(02) 将x父节点设为“黑色”。
(03) 将x兄弟节点的右子节设为“黑色”。
(04) 对x的父节点进行左旋。
(05) 设置“x”为“根节点”。
</pre>
<pre>
        P()                        S()
       /  \                       /   \
     X(B) S(B)        --->      P(B) Sr(B)
            \                   /
            Sr(R)             X(B)
</pre>
* 我们处理“Case 4”的目的是：去掉x中额外的黑色，将x变成单独的黑色。处理的方式是：进行颜色修改，然后对x的父节点进行左旋。之后咱会发现，X 所在路线上相比之前多了一个黑色的节点 P ，意味着之前删掉的黑色节点被成功的补回来了，另外，经过 S 的节点的路径，由于 Sr 由之前的红色变成了黑色，也就是说，虽然 S 不一定是黑色（原来 P 的颜色），但是，总的来说，和变之前，黑色节点的数目是没有一样的。于是，整个红黑树的性质有变得满足了，大功告成，可以将 X 设置为根节点来结束 while 循环<br><br>

#### 双黑修正总结
双黑修正比双红修正复杂了很多，而且哥 case 的关联程度也比双红的来得更复杂、更强。为了方便形成较好的理解，我描了一个如下的流程图。
<pre>
                1.若满足case 1 --------                                 否则go case 4
               |-----------> | case 1 |------、--------------------、---------------、                  (while start)
               |              --------  若满足|case 2     否则，若满足|case 3          |                        ^
               |2.若满足case 2            --------                  |                |      go while loop     |
               |----------------------> | case 2 | ----------------)----------------)------------------------/ 
(while start)--|                         --------                  |                |---、    
               |3.否则，若满足case 3                              --------  go case4      |
               |---------------------------------------------> | case 3 | ----------、  | 
               |                                                --------            |   |
               |4.否则，若不满足case 3                                                --------
               |-----------------------------------------------------------------> | case 4 | ---------> (end while)
                                                                                    --------
</pre>

## 参考文献 <br>
[红黑树的原理分析与(C++)实现](https://blog.csdn.net/amoscykl/article/details/81607530) <br>
[红黑树(一)之 原理和算法详细介绍](https://www.cnblogs.com/skywang12345/p/3245399.html) <br>
[教你初步了解红黑树](https://blog.csdn.net/v_JULY_v/article/details/6105630) <br>
[The-Art-Of-Programming-By-July](https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md) <br>
[算法导论 之 红黑树 - 删除[C语言]](https://blog.csdn.net/qifengzou/article/details/17608863)
